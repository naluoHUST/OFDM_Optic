# -*- coding: utf-8 -*-
"""OFD_Optic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pUcNKYXerChZFKphbKrjQ6FMybCqarvw
"""

import numpy as np
import itertools
import matplotlib.pyplot as plt

class ACO:
    def __init__(self, Nsubcarrier, M):
        self.K = Nsubcarrier
        self.M = M
        self.snr_db = 25
        self.data = np.random.binomial(n=1, p=0.5, size=self.K * self.M)
        self.mapping = self.qam_mapping(2 ** M)

        self.symbol = self.S_P(self.data, M)
        self.symbol_mapped = self.Mapping(self.symbol)
        self.HermittianSymetry = self.hermitian_aco(self.symbol_mapped, Nsubcarrier)
        self.AfterIFFT = self.IFFT(self.HermittianSymetry)
        self.AfterClipping = self.Clipping(self.AfterIFFT)
        self.ACO_RX = self.channel(self.AfterClipping, self.snr_db)
        self.AfterFFT = self.FFT(self.ACO_RX)
        self.symbol_ext = self.message_ext(self.AfterFFT)

    def S_P(self, bits, M):
        return bits.reshape(-1, M)

    def qam_mapping(self, M):
        n = int(np.log2(M))
        mapping = {}
        for i, bits in enumerate(itertools.product([0, 1], repeat=n)):
            I = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[:n // 2])]) - (2 ** (n // 2)) + 1
            Q = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[n // 2:])]) - (2 ** (n // 2)) + 1
            mapping[bits] = I + 1j * Q
        return mapping

    def Mapping(self, bits):
        return np.array([self.mapping[tuple(b)] for b in bits])

    def hermitian_aco(self, symbol_mapped, K):
        SYMETRICarray = np.zeros(K, dtype=complex)

        odd_index = 1
        for i in range(len(symbol_mapped)):
            if odd_index < K // 2:
                SYMETRICarray[odd_index] = symbol_mapped[i]
                SYMETRICarray[K - odd_index] = np.conjugate(symbol_mapped[i])
                odd_index += 2
        return SYMETRICarray

    def IFFT(self, HermittianSymetry):
        return np.fft.ifft(HermittianSymetry)

    def Clipping(self, AfterIFFT):
        clippedsignal = np.maximum(AfterIFFT, 0)
        return clippedsignal

    def channel(self, signal, snr_db):
        Channel_response = np.array([1])
        Y = np.convolve(signal, Channel_response)[:len(signal)]
        signal_power = np.mean(np.abs(Y) ** 2)
        noise_power = signal_power * 10 ** (-snr_db / 10)
        noise = np.sqrt(noise_power / 2) * np.random.randn(*Y.shape)
        return Y + noise

    def FFT(self, ACO_RX):
        return np.fft.fft(ACO_RX)

    def message_ext(self, AfterFFT):
        symbol_ext = []
        for i in range(len(AfterFFT)//2):
            if i % 2 != 0:
                symbol_ext.append(2 * AfterFFT[i])
        return np.array(symbol_ext)

    def PS(self, bits):
        return bits.reshape((-1,))

    def plot_signals(self):

        real_hermitian = np.real(self.HermittianSymetry)
        imag_hermitian = np.imag(self.HermittianSymetry)

        real_ifft = np.real(self.AfterIFFT)
        imag_ifft = np.imag(self.AfterIFFT)

        real_clipped = np.real(self.AfterClipping)
        imag_clipped = np.imag(self.AfterClipping)

        subcarrier_index = np.arange(self.K)

        plt.figure(figsize=(20, 5))


        plt.subplot(1, 2, 1)
        plt.stem(subcarrier_index, real_hermitian, linefmt='b-', markerfmt='bo', basefmt='r-', label='Re')
        plt.stem(subcarrier_index, imag_hermitian, linefmt='r-', markerfmt='ro', basefmt='r-', label='Im')
        plt.title('After Hermitian Symmetry')
        plt.xlabel('Subcarrier Index')
        plt.ylabel('Amplitude')
        plt.legend()
        plt.grid(True, which='both', linestyle='--', linewidth=0.5)


        for idx in subcarrier_index:
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)

        plt.figure(figsize=(20,5))
        plt.subplot(1, 2, 2)
        plt.plot(np.arange(len(real_ifft)), real_ifft, 'b-', label='Before Clipping')
        plt.plot(np.arange(len(real_clipped)), real_clipped, 'r--', label='After Clipping')
        plt.title('Before and After Clipping')
        plt.xlabel('Time slot')
        plt.ylabel('Amplitude')
        plt.legend()
        plt.grid(True, which='both', linestyle='--', linewidth=0.5)


        for idx in range(0, len(real_ifft), self.K // 10):
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)
        for idx in range(0, len(real_clipped), self.K // 10):
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)
        for idx in subcarrier_index:
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)
        plt.tight_layout()
        plt.show()

Cam = ACO(64, 4)
Cam.plot_signals()

import numpy as np
import itertools
import matplotlib.pyplot as plt

class ACO:
    def __init__(self, Nsubcarrier, M):
        self.K = Nsubcarrier
        self.M = M
        self.data = np.random.binomial(n=1, p=0.5, size=self.K * self.M)
        self.mapping = self.qam_mapping(2 ** M)
        self.SNRdB = np.linspace(-25, 25)
        self.symbol = self.S_P(self.data, M)
        self.symbol_mapped = self.Mapping(self.symbol)
        self.HermittianSymetry = self.hermitian_aco(self.symbol_mapped, Nsubcarrier)
        self.AfterIFFT = self.IFFT(self.HermittianSymetry)
        self.AfterClipping = self.Clipping(self.AfterIFFT)
        demapping_table = {v: k for k, v in self.mapping.items()}

    def calculate_ber(self):
      self.BER = []

      demapping_table = {v: k for k, v in self.mapping.items()}

      for snr_db in self.SNRdB:
          ber_iteration = []

          for _ in range(10000):
              self.ACO_RX = self.channel(self.AfterClipping, snr_db)
              self.AfterFFT = self.FFT(self.ACO_RX)
              self.symbol_ext = self.message_ext(self.AfterFFT)
              self.Afterdemap, _ = self.demapping(self.symbol_ext, demapping_table)
              self.dataouput = self.P_S(self.Afterdemap)

              # so sánh độ dài 2 chuỗi data, chuỗi nào ngắn hơn thì cắt chuỗi còn lại
              min_len = min(len(self.data), len(self.dataouput))
              ber_iteration.append(np.mean(self.data[:min_len] != self.dataouput[:min_len]))


          self.BER.append(np.mean(ber_iteration))

    def S_P(self, bits, M):
        return bits.reshape(-1, M)

    def qam_mapping(self, M):
        n = int(np.log2(M))
        mapping = {}
        for i, bits in enumerate(itertools.product([0, 1], repeat=n)):
            I = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[:n // 2])]) - (2 ** (n // 2)) + 1
            Q = 2 * sum([bit * (2 ** (n // 2 - j - 1)) for j, bit in enumerate(bits[n // 2:])]) - (2 ** (n // 2)) + 1
            mapping[bits] = I + 1j * Q
        return mapping

    def Mapping(self, bits):
        return np.array([self.mapping[tuple(b)] for b in bits])

    def hermitian_aco(self, symbol_mapped, K):
        SYMETRICarray = np.zeros(K, dtype=complex)

        odd_index = 1
        for i in range(len(symbol_mapped)):
            if odd_index < K // 2:
                SYMETRICarray[odd_index] = symbol_mapped[i]
                SYMETRICarray[K - odd_index] = np.conjugate(symbol_mapped[i])
                odd_index += 2
        return SYMETRICarray

    def IFFT(self, HermittianSymetry):
        return np.fft.ifft(HermittianSymetry)

    def Clipping(self, AfterIFFT):
        clippedsignal = np.maximum(AfterIFFT, 0)
        return clippedsignal

    def channel(self, signal, snr_db):
        Channel_response = np.array([1])
        Y = np.convolve(signal, Channel_response)[:len(signal)]
        signal_power = np.mean(np.abs(Y) ** 2)
        noise_power = signal_power * 10 ** (-snr_db / 10)
        noise = np.sqrt(noise_power / 2) * np.random.randn(*Y.shape)
        return Y + noise

    def FFT(self, ACO_RX):
        return np.fft.fft(ACO_RX)

    def message_ext(self, AfterFFT):
        symbol_ext = []
        for i in range(len(AfterFFT)//2):
            if i % 2 != 0:
                symbol_ext.append(2 * AfterFFT[i])
        return np.array(symbol_ext)

    def demapping(self, mapping, demapping_table):
        constel = np.array([x for x in demapping_table.keys()])
        dis = abs(mapping.reshape((-1, 1)) - constel.reshape((1, -1)))
        constel_index = dis.argmin(axis=1)
        HDecision = constel[constel_index]
        return np.vstack([demapping_table[C] for C in HDecision]), HDecision

    def P_S(self, bits):
        return bits.reshape((-1,))

    def plot_signals(self):

        real_hermitian = np.real(self.HermittianSymetry)
        imag_hermitian = np.imag(self.HermittianSymetry)

        real_ifft = np.real(self.AfterIFFT)
        imag_ifft = np.imag(self.AfterIFFT)

        real_clipped = np.real(self.AfterClipping)
        imag_clipped = np.imag(self.AfterClipping)

        subcarrier_index = np.arange(self.K)

        plt.figure(figsize=(20, 5))


        plt.subplot(1, 2, 1)
        plt.stem(subcarrier_index, real_hermitian, linefmt='b-', markerfmt='bo', basefmt='r-', label='Re')
        plt.stem(subcarrier_index, imag_hermitian, linefmt='r-', markerfmt='ro', basefmt='r-', label='Im')
        plt.title('After Hermitian Symmetry')
        plt.xlabel('Subcarrier Index')
        plt.ylabel('Amplitude')
        plt.legend()
        plt.grid(True, which='both', linestyle='--', linewidth=0.5)


        for idx in subcarrier_index:
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)

        plt.figure(figsize=(20,5))
        plt.subplot(1, 2, 2)
        plt.plot(np.arange(len(real_ifft)), real_ifft, 'b-', label='Before Clipping')
        plt.plot(np.arange(len(real_clipped)), real_clipped, 'r--', label='After Clipping')
        plt.title('Before and After Clipping')
        plt.xlabel('Time slot')
        plt.ylabel('Amplitude')
        plt.legend()
        plt.grid(True, which='both', linestyle='--', linewidth=0.5)


        for idx in range(0, len(real_ifft), self.K // 10):
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)
        for idx in range(0, len(real_clipped), self.K // 10):
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)
        for idx in subcarrier_index:
            plt.axvline(x=idx, color='gray', linestyle='--', linewidth=0.5)
        plt.tight_layout()
        plt.show()




Cam = ACO(1024, 6)
Pink = ACO(1024, 4)
Cam1 = ACO(1024, 2)
Cam.calculate_ber()
Pink.calculate_ber()
Cam1.calculate_ber()
plt.ylim(10**-5,1)
plt.figure(figsize=(8, 4))
plt.plot(Cam.SNRdB, Cam.BER, 'bo-', label='1024 Subcarriers, 64-QAM')
plt.plot(Pink.SNRdB, Pink.BER, 'mo-', label='1024 Subcarriers, 16-QAM')
plt.plot(Cam1.SNRdB, Cam1.BER, 'ro-', label='1024 Subcarriers, 4-QAM')

plt.semilogy()
plt.xlabel('SNR (dB)')
plt.ylabel('BER')
plt.legend()
plt.title('BER for ACO-OFDM')
plt.grid(True)
plt.show()